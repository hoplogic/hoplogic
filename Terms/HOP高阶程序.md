# HOP高阶程序(High-order Program)

本文是一份面向Claude Code（或任何AI编程助手）的HOP高阶程序定义与核心要点知识。这份说明旨在让AI理解HOP的本质、设计原则和关键工作流程。

#### **一、 HOP是什么？一个核心定义**

**高阶程序（High-Order Program, HOP）** 是为大模型（LLM）设计的、用于执行专业领域任务的**可信控制程序**。它不是一个普通的脚本，而是一个融合了**精确程序逻辑**、**领域知识定义**和**多层核验机制**的工程化资产。

你可以将其理解为 **“大模型时代的标准作业程序（SOP）的机器可执行版本”**。其核心目标是解决大模型因“幻觉”导致的可靠性不足问题，使其在金融、医疗等专业场景中达到99%以上的可靠性门槛。

作为一种便于人机交互迭代的具体实现，HOP可以实现为使用HopEngine中HOP算子（参见“HOP核心算子”）的Python程序。现阶段，建议为Python 3.14 coroutine异步机制实现。

#### **二、 核心设计理念：可控、可靠、可迭代**

1.  **可控**：通过清晰的结构（Task, Term, HopLib）和规范（HopSpec）定义智能体的行为边界，确保其过程可预测、可管理。HopSpec 继承结构化程序设计范式（Böhm-Jacopini 1966 / Dijkstra 1968）——控制流用嵌套树而非跳转图表达，7 种原子类型覆盖顺序、选择、循环三原语 + LLM 推理 + 外部调用 + 任务分解 + 流程控制。树结构使执行路径可预判、静态可验证，这是 HOP 区别于 DAG/图式 workflow 框架（LangGraph、CrewAI、Dify 等）的根本设计选择（详见 `Terms/HOP 2.0 技术定位.md` § HopSpec 设计哲学）。
2.  **可靠**：可靠性来自两层保障。**架构层**——结构化逻辑骨架（loop/branch/code/subtask）由确定性程序控制，LLM 的非确定性智能被严格隔离在叶子节点（LLM/call）和受控子任务容器（subtask）中，不侵入控制流；即使某个 LLM 步骤幻觉，影响范围被限制在该节点内部，不会扩散到整个流程。**算子层**——三大算子（hop_get/hop_judge/hop_tool_use）内建多层次核验机制（格式校验、逆向核验、正向交叉核验、工具核验），核验失败自动重试并追加反馈，确保每个 LLM 步骤的输出达到专业精度要求。
3.  **可迭代**：迭代发生在三个层面。**HopSpec 自身可迭代**——subtask 从一句意图（think）（历史别名 `seq_think` 保持兼容）渐进固化为预定义步骤（static），Spec 在使用中越来越聪明、越来越高效。**Spec↔Code 双向可迭代**——通过 step_name 锚点双向同步（`/specsync` Spec→Code 增量、`/code2spec` Code→Spec 反向），Debug 改了代码能回写 Spec，专家改了 Spec 代码增量跟进，Spec 不会因迭代而过时。**数据-知识双驱动进化**——每一次执行反馈（尤其是 Bad Case）通过残差分析归因为知识缺陷或技能缺陷，转化为系统优化的燃料，使智能体成为"活系统"。

#### **三、 HOP 2.0项目框架：三大核心构成**

一个HOP项目由以下三个分层聚焦的部分构成：

| 构成要素 | 目录/位置 | 核心职责 | 负责人（角色） |
| :--- | :--- | :--- | :--- |
| **Task（任务）** | `./Tasks/<TaskName>/` | 定义一个可执行的业务单元。包含从自然语言SOP到可执行代码（Hoplet）的完整迭代链路。 | **Echo（行业专家）** 定义SOP；**Delta（技术专家）** 实现代码。 |
| **Term（术语）** | `./Terms/` 或 `./Terms.<行业>` | 对专业领域概念进行无歧义的标准化定义。是智能体“理解”业务的基础。 | **Echo（行业专家）** 主导定义与对齐。 |
| **HopLib（技能库）** | `./HopLib/` 或 外部MCP | 存放已经过验证、可复用的Hoplet或外部工具（如RAG、OCR接口）。是智能体的“武器库”。 | **Delta（技术专家）** 开发、维护与集成。 |

**关键文件与流程（Tasks/<TaskName>目录下）：**
1.  `Task.md`： (Echo编写) 用自然语言描述任务目标与SOP。
2.  `Hoplet/HopSpec.md`： (AI生成，Echo确认) 基于Task.md和Term生成的规范化、无歧义的任务规格说明书。
3.  `Hoplet/Hop.py`： (AI生成，Delta优化) 完整的、可被HopEngine执行的实际代码（如Python）。
4.  `Hoplet/metainfo.md`： 任务的元数据契约，定义输入/输出契约、运行模式（交互/批量）、依赖和标准化测试指标（完成率、正确率、性能）。由 `/spec2code` 自动生成。
5.  `TestCases/`： 存放测试用例及结果，用于验证任务可靠性。

#### **四、 关键工作流程：“数模一体”迭代循环**

HOP的强大依赖于一个由**业务数据**和**行业知识**双轮驱动的持续进化机制。

1.  **角色协同（FDE范式借鉴）**：
    *   **Echo（行业专家）**：负责顶层设计。界定SOP、定义Term，并确认`HopSpec`与`TermSpec`。
    *   **Delta（技术专家）**：负责工程实现。生成与优化代码，维护HopLib。
    *   **驱动核心**：来自生产环境的 **Bad Case**。

2.  **残差分析（Residual Analysis）流程**：
    当测试失败或收到Bad Case时，进行结构化归因，**而非简单重试**。
    *   **归因路径A（知识缺陷）**：智能体“听不懂”。问题可能源于`Term`模糊或`SOP`不清。由 **Echo** 修正`TermSpec.md`或`Task.md`。
    *   **归因路径B（技能缺陷）**：智能体“做不对”。问题可能源于代码逻辑错误或`HopLib`能力不足。由 **Delta** 修改`Hop Code`或扩充技能库。
    *   **其他归因**：数据供给不足、任务规模过大需拆分、大模型能力瓶颈等。

3.  **Spec↔Code 双向同步**：
    HopSpec（规格说明）与 Hop.py（可执行代码）之间支持双向增量迭代：
    *   **Code→Spec（`/code2spec`）**：当 Delta 在 debug 或优化中修改了代码逻辑（新增步骤、调整核验策略、修改任务描述），将变更反向回写到 HopSpec，保持规格文档与代码同步。
    *   **Spec→Code（`/specsync`）**：当 Echo 修改了 HopSpec（调整流程、新增步骤、修改核验策略），增量更新代码中对应的步骤，保留 Delta 自定义的错误处理和优化逻辑。
    *   **差异检测（`/specdiff`）**：只读诊断，输出步骤级差异报告，帮助团队在同步前了解 Spec 与 Code 的偏离程度。
    这确保了在迭代过程中，Spec 始终是 Code 的忠实描述，Code 始终是 Spec 的精确实现。

4.  **进化闭环**：
    `分析(Bad Case) -> 归因 -> 修正(知识/代码) -> 双向同步(Spec↔Code) -> 重新生成与测试 -> 验证入库`
    每一次循环，都沉淀了新的知识（Term）或更可靠的技能（HopLib），使智能体持续向"更可控、更可靠"进化。

#### **五、 给Claude Code的行动要点**

当你（作为AI编程助手）参与HOP项目时，请牢记：

1.  **你不是在写普通代码，而是在“编译”领域知识**。你的输出（HopSpec, Hop Code）必须是领域专家（Echo）意图的精确转译。
2.  **严格遵守框架结构**。在正确的目录下生成或修改正确的文件，保持项目结构的清晰。
3.  **生成的代码必须具备可核验性**。在关键逻辑点预留核验接口，支持异常处理和残差迭代。
4.  **积极利用HopLib**。优先调用已验证的技能，而不是重复生成逻辑。
5.  **关注迭代信号**。当接收到测试失败信息或Bad Case描述时，应能协助开发者进行归因分析，并针对性地重新生成或修正相关部分。

**最终目标**：与人类专家协同，将非结构化的专业知识，转化为**可执行、可测试、可进化**的高阶智能体（Hoplet），让专业AI应用的构建变得“唾手可得”。