# HopletView Architecture Specification

This document is a comprehensive architecture specification for the Hoplet View layer, targeting AI programming assistants and developers. It defines a unified UI architecture spanning from local desktop to cloud web services, guiding the `/code2view` command to generate standardized View directory structures.

> Reference implementation: `Tasks/Verify/View/` (current pywebview single-file implementation)  
> Engine interfaces: `hoplogic/hop_engine/core/state_store.py`, `hop_engine/core/status_recorder.py`

---

## 1. Design Motivation

### Current Problems

The current Hoplet View layer (using `Tasks/Verify/View/` as example) has these issues:

1. **No layered design** - Business logic, transport adapters, and data queries are mixed in the `Api` class in `app.py`. File parsing (`_parse_file`), statistical aggregation (`get_stats`), batch execution (`_batch_worker`), and pywebview bindings are all coupled together
2. **No web service support** - Only pywebview desktop mode for single-user local use. Cannot support team collaboration for online viewing of test results or triggering batch tests
3. **Inefficient data queries** - `_parse_file` manually reads JSONL + Python loops for statistical aggregation. With data growth (10k+ TestCases records), memory usage and response time increase linearly
4. **No structured logging** - Hoplet execution process is unobservable (only final JSONL results). Operator-level timing, retry counts, intermediate states, and performance data are lost when process exits
5. **`/code2view` only generates 2 files** - `app.py` + `index.html`, lacking standardized directory structure and separation of concerns

### Goals

- **Local + cloud dual mode**: Same business logic with Transport layer adapting pywebview (local desktop) and FastAPI (web service)
- **Data query acceleration**: JSONL remains source of truth, DuckDB as query acceleration layer, ibis provides type-safe expression API
- **Structured observability**: HopletObserver records execution process logs (JSONL format, compatible with `JsonlStateStore`) for DataStore layer queries
- **Standardized architecture**: `/code2view` generates 6 files (instead of 2), following five-layer layered design

---

## 2. Architecture Overview

### SSR Architecture

```
┌───────────────────────────────────────────────┐
│  Frontend (index.html)                        │  HTML/CSS/JS, Tab-style UI
│  ┌─────────────────────────────────────────┐  │
│  │  HTMX (hx-get, hx-post, hx-swap)       │  │  Declarative HTTP interaction
│  └─────────────────────────────────────────┘  │
└───────────────┬───────────────────────────────┘
                │  HTTP (GET/POST)
┌───────────────┴───────────────────────────────┐
│  Transport Layer (unified HTTP)               │
│  ┌─────────────┐  ┌────────────────────────┐  │
│  │ app.py      │  │ web.py                 │  │
│  │ (pywebview  │  │ (FastAPI + uvicorn)    │  │
│  │  + embedded │  │                        │  │
│  │  uvicorn)   │  │                        │  │
│  └──────┬──────┘  └───────────┬────────────┘  │
└─────────┼─────────────────────┼───────────────┘
          │                     │
┌─────────┴─────────────────────┴───────────────┐
│  Renderer (Jinja2 templates)                  │  HTML fragment rendering
│  render_tab() / render_stats() / ...          │
└───────────────┬───────────────────────────────┘
                │ await service.*
┌───────────────┴───────────────────────────────┐
│  Service Layer (service.py)                   │  Pure async, dict in/out
│  Assemble DataStore + Observer + HopProc      │
└───────────────┬───────────────────────────────┘
                │
┌───────────────┴───────────────────────────────┐
│  DataStore Layer (datastore.py)               │  DuckDB + ibis queries
│  JSONL → DuckDB → statistics/filter/aggregate │
└───────────────────────────────────────────────┘

┌───────────────────────────────────────────────┐
│  HopletObserver (observer.py)                 │  Structured logs (JSONL)
│  trace_run / trace_step context managers       │
└───────────────────────────────────────────────┘
```

### Directory Structure

```
Tasks/<TaskName>/
├── Hoplet/
│   ├── metainfo.md
│   ├── HopSpec.md
│   └── Hop.py
├── TestCases/                    # Test results JSONL (source of truth)
└── View/                         # Generated by /code2view
    ├── ViewSpec/                 # UI specification directory
    │   ├── index.md              #   Overview + Tab list + interaction customization + file routing table + file index
    │   ├── rendering.md          #   Rendering mappings
    │   └── theme.md              #   Layout theme
    ├── config.py                 # ViewConfig declaration (~35 lines)
    ├── app.py                    # Transport: pywebview (embedded uvicorn HTTP service)
    ├── web.py                    # Transport: FastAPI Web Service (SSR, returns HTML)
    ├── index.html                # Frontend: UI (HTMX-driven interaction)
    └── test/                     # Test suite (generated by /code2view)
        ├── pytest.ini            # asyncio_mode = auto
        ├── __init__.py           # Empty package marker
        ├── conftest.py           # Shared fixtures
        ├── test_web.py           # web.py endpoint tests
        ├── test_config.py        # config.py tests
        └── test_service.py       # service.py tests (shared library BaseService)
```

### Layer Dependency Rules

```
index.html  →  app.py / web.py  →  service.py  →  datastore.py
                                                →  observer.py
```

- **Frontend** initiates HTTP requests via HTMX declarative attributes, receives HTML fragment responses
- **Transport** uses unified HTTP paths (pywebview embedded uvicorn, FastAPI direct service), generates HTML through Renderer
- **Renderer** uses Jinja2 to render Service-returned dict as HTML fragments
- **Service** is pure async functions returning `dict`, independent of any Transport framework
- **DataStore** and **Observer** are Service dependencies, independent of each other

### Path Resolution Constraints (Launch from Any Directory)

**All View launchers (app.py / web.py) must support launching from any working directory**, without depending on `os.getcwd()`. Specific requirements:

1. **All paths calculated based on `__file__`**: `VIEW_DIR`, `TASK_DIR`, `HOPLET_DIR`, `TESTCASES_DIR` etc. are derived via `os.path.abspath(__file__)` upward, no relative paths used
2. **Explicit `sys.path` management**: Launchers must add `VIEW_DIR` (for `from config import ...`) and `HOPLOGIC_DIR` (for `from hop_view import ...`) to `sys.path`, with deduplication checks
3. **HOPLOGIC_DIR calculation**: `os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))` (from `Tasks/<Task>/View/` up three levels to project root, then into `hoplogic/`)
4. **Prohibit `os.chdir()` in launchers**: `chdir` only used temporarily inside `ensure_hop()` and restored

Template:
```python
VIEW_DIR = os.path.dirname(os.path.abspath(__file__))
HOPLOGIC_DIR = os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))
if VIEW_DIR not in sys.path:
    sys.path.insert(0, VIEW_DIR)
if HOPLOGIC_DIR not in sys.path:
    sys.path.insert(0, HOPLOGIC_DIR)
```

---

## 3. DataStore Layer (DuckDB + ibis)

### Design Principles

1. **JSONL is source of truth** - All test results and execution logs are persisted as JSONL files (compatible with `JsonlStateStore` format). DuckDB does not persist database files, only builds query views in memory
2. **On-demand loading** - `load_results()` loads from JSONL files into DuckDB memory tables, subsequent queries use ibis expression API
3. **Side-effect free** - DataStore only reads JSONL, does not write or modify any files

### Core Class: BaseDataStore

```python
"""datastore.py — DuckDB + ibis query acceleration layer"""

import ibis

from hop_view.config_schema import ViewConfig

class BaseDataStore:
    """TestCases query engine based on ibis + DuckDB

    JSONL is source of truth, DuckDB is memory query acceleration layer, ibis provides type-safe expression API.
    ViewConfig drives statistical aggregation, sorting whitelist, and other behaviors.
    """

    def __init__(self, config: ViewConfig, testcases_dir: str,
                 observer_log: str | None = None):
        self.config = config
        self.testcases_dir = testcases_dir
        self.observer_log = observer_log
        self.con = ibis.duckdb.connect()

    def load_results(self, force_reload: bool = False) -> int:
        """Load JSONL from TestCases/ into DuckDB memory table"""
        ...

    def get_stats(self, profile: str | None = None) -> dict:
        """Aggregate statistics — driven by ViewConfig.output_fields configuration

        Generate corresponding ibis expressions by field agg_type:
        - mean         → .try_cast("float64").mean().round(1)
        - rate         → .try_cast("bool").fill_null(False).sum() / total
        - distribution → DuckDB SQL (from_json + UNNEST)
        - non_null_rate→ .notnull().sum() / total
        """
        ...

    def get_error_distribution(self) -> list[dict]:
        """Error type distribution"""
        ...

    def get_perf_summary(self) -> dict:
        """Performance summary (queried from observer logs)"""
        ...

    def query_results(self, *, offset: int = 0, limit: int = 50,
                      sort_by: str | None = None, ascending: bool = False,
    ) -> list[dict]:
        """Paginated query of test results"""
        ...

    def close(self) -> None:
        """Close DuckDB connection"""
        self.con.disconnect()
```

### ibis Expression Query Examples

DataStore uses ibis expression API to query DuckDB (type-safe, no SQL concatenation):

```python
# Statistical aggregation (try_cast handles VARCHAR numeric fields)
t = con.table("results")
total = t.count().execute()  # → Python int
avg_score = t["credit_score"].try_cast("float64").mean().round(1).execute()

# Boolean rate statistics
cnt = t["active"].try_cast("bool").fill_null(False).sum().execute()
rate = round(cnt / total, 4)

# Paginated query (returns list[dict], no pandas)
rows = (
    t.order_by(ibis.desc("score"))
    .limit(50, offset=0)
    .to_pyarrow()
    .to_pylist()
)

# Performance percentiles (from observer log table)
obs = con.table("observer_log")
runs = obs.filter(obs.type == "run_end")
run_stats = runs.aggregate(
    total_runs=runs.count(),
    avg_duration=runs.duration.cast("float64").mean(),
    p50=runs.duration.cast("float64").quantile(0.5),
    p95=runs.duration.cast("float64").quantile(0.95),
).to_pyarrow().to_pylist()

# Error type distribution (DuckDB-specific from_json + UNNEST, keep raw SQL)
expr = con.sql(
    "SELECT e->>'severity' AS val, COUNT(*) AS cnt "
    "FROM results, UNNEST(from_json(errors, '[\"json\"]')) AS t(e) "
    "WHERE errors IS NOT NULL "
    "GROUP BY val ORDER BY cnt DESC"
)
dist = expr.to_pyarrow().to_pylist()
```

### Comparison with `_parse_file`

| Dimension | Current Implementation (`_parse_file` + Python loops) | DataStore (ibis → DuckDB) |
|-----------|--------------------------------------------------------|---------------------------|
| Data Loading | Full file read per request | On-demand load to memory table, incremental refresh |
| Aggregation | Python for loops accumulate | ibis → DuckDB vectorized execution |
| 10k Data Response | Seconds (depends on Python interpreter) | Milliseconds (DuckDB columnar engine) |
| Percentile Stats | Manual sorting + indexing | `runs.duration.quantile(0.95)` one line |
| Memory Management | All JSON objects resident | DuckDB columnar compression |

---

## 4. HopletObserver (Structured Logging)

### Design Principles

1. **Write JSONL, read via DuckDB** - Observer only writes structured logs to JSONL files, queries and statistics handled by DataStore layer
2. **Compatible with `JsonlStateStore` format** - Log records' `type`, `run_id`, `timestamp`, `duration` etc. fields match `JsonlStateStore` format in `state_store.py`, can share same DuckDB table
3. **Lightweight** - No additional dependencies (only `json` + `threading`), doesn't affect Hoplet execution performance

### Log Format

Each log is one JSON line with these fields:

```jsonl
{"type":"run_start","run_id":"abc-123","timestamp":1700000000.0,"input":{...},"hoplet":"verify_model_output"}
{"type":"step","run_id":"abc-123","timestamp":1700000001.2,"step":1,"op":"hop_get","task":"Break down atomic facts","status":"OK","duration":3.45,"retry_count":0}
{"type":"step","run_id":"abc-123","timestamp":1700000005.8,"step":2,"op":"hop_get","task":"Traceability judgment","status":"OK","duration":4.56,"retry_count":1}
{"type":"run_end","run_id":"abc-123","timestamp":1700000020.0,"duration":20.0,"status":"OK","result":{...}}
```

Field descriptions:

| Field | Type | Description |
|-------|------|-------------|
| `type` | `str` | `"run_start"` / `"step"` / `"run_end"` — compatible with `JsonlStateStore`'s `"step"` / `"function"` |
| `run_id` | `str` | Execution batch identifier (matches `HopSession.run_id`) |
| `timestamp` | `float` | Unix timestamp (`time.time()`) |
| `step` | `int` | Step number (only when `type=="step"`) |
| `op` | `str` | Operator name (only when `type=="step"`) |
| `task` | `str` | Task description (only when `type=="step"`) |
| `status` | `str` | `"OK"` / `"FAIL"` / `"UNCERTAIN"` / `"LACK_OF_INFO"` |
| `duration` | `float` | Duration in seconds |
| `retry_count` | `int` | Retry count (only when `type=="step"`) |
| `input` | `dict` | Input data (only when `type=="run_start"`) |
| `result` | `dict` | Final result (only when `type=="run_end"`) |
| `hoplet` | `str` | Hoplet name (only when `type=="run_start"`) |
| `metadata` | `dict` | Optional extension fields |

### Core Class: HopletObserver

```python
"""observer.py — lightweight structured logging"""

import json
import threading
import time
from contextlib import contextmanager

class HopletObserver:
    """Structured logger for Hoplet execution process

    Writes JSONL files, reads handled by DataStore (DuckDB).
    Thread-safe (threading.Lock protects file writes).
    """

    def __init__(self, log_path: str):
        self.log_path = log_path
        self._lock = threading.Lock()

    def _append(self, record: dict) -> None:
        line = json.dumps(record, ensure_ascii=False) + "\n"
        with self._lock:
            with open(self.log_path, "a", encoding="utf-8") as f:
                f.write(line)

    @contextmanager
    def trace_run(self, run_id: str, hoplet: str, input_data: dict):
        """Record a complete Hoplet execution

        Usage:
            with observer.trace_run(run_id, "verify", input_data) as tracer:
                tracer.trace_step(1, "hop_get", "Break down atomic facts", "OK", 3.45, 0)
                ...
        """
        self._append({
            "type": "run_start",
            "run_id": run_id,
            "timestamp": time.time(),
            "hoplet": hoplet,
            "input": input_data,
        })
        start = time.time()
        tracer = _RunTracer(self, run_id)
        try:
            yield tracer
        except Exception as e:
            self._append({
                "type": "run_end",
                "run_id": run_id,
                "timestamp": time.time(),
                "duration": round(time.time() - start, 4),
                "status": "FAIL",
                "metadata": {"error": str(e)},
            })
            raise
        else:
            self._append({
                "type": "run_end",
                "run_id": run_id,
                "timestamp": time.time(),
                "duration": round(time.time() - start, 4),
                "status": tracer.last_status or "OK",
                "result": tracer.last_result,
            })


class _RunTracer:
    """Step recorder within trace_run context"""

    def __init__(self, observer: HopletObserver, run_id: str):
        self._observer = observer
        self._run_id = run_id
        self.last_status: str | None = None
        self.last_result: dict | None = None

    def trace_step(
        self, step: int, op: str, task: str,
        status: str, duration: float, retry_count: int = 0,
        metadata: dict | None = None,
    ) -> None:
        record = {
            "type": "step",
            "run_id": self._run_id,
            "timestamp": time.time(),
            "step": step,
            "op": op,
            "task": task,
            "status": status,
            "duration": round(duration, 4),
            "retry_count": retry_count,
        }
        if metadata:
            record["metadata"] = metadata
        self._observer._append(record)
        self.last_status = status

    def set_result(self, result: dict) -> None:
        self.last_result = result
```

### Relationship with `JsonlStateStore`

| Dimension | `JsonlStateStore` | `HopletObserver` |
|-----------|-------------------|------------------|
| Write Timing | Inside engine (`auto_record_status` decorator auto-calls) | View layer (`service.py` explicitly calls before/after Hoplet execution) |
| Record Granularity | Operator-level (step) + function-level (function) | Run-level (run_start/run_end) + operator-level (step) |
| Focus | Engine observability (retries, exception chains) | UI observability (input/output, execution traces) |
| Field Compatibility | `type`, `run_id`, `timestamp`, `step`, `op`, `duration`, `status` | Same field names + additional `input`, `result`, `hoplet` |
| Query Method | External tools read | DataStore (DuckDB) queries |

Both write to different JSONL files, but DataStore can load both into DuckDB for joint queries. If `HopSession` already has `state_store` configured, Observer's step-level logs can be omitted (to avoid duplication), only recording `run_start` and `run_end`.

---

## 5. Service Layer

### Design Principles

1. **Pure async + dict in/out** - All methods are async functions, receive dict parameters, return dict results. Independent of any Transport framework (pywebview / FastAPI)
2. **Assembly layer** - Assembles DataStore, Observer, HopProc, coordinates execution flow
3. **Stateless methods** - Each call is independent (batch test progress state managed via `_batch` dict, single-process only)

### Core Class: HopletService

```python
"""service.py — pure business logic, Transport-independent"""

import asyncio
from dataclasses import dataclass, field

@dataclass
class BatchProgress:
    running: bool = False
    completed: int = 0
    total: int = 0
    errors: int = 0
    output_file: str = ""

class HopletService:
    """Hoplet View business logic layer

    Pure async methods, dict in/out.
    Transport layer (app.py / web.py) calls this class's methods and serializes to JSON.
    """

    def __init__(
        self,
        hoplet_dir: str,
        testcases_dir: str,
        observer: HopletObserver | None = None,
    ):
        self.hoplet_dir = hoplet_dir
        self.testcases_dir = testcases_dir
        self.datastore = HopletDataStore(testcases_dir)
        self.observer = observer
        self._hop_module = None
        self._batch = BatchProgress()

    # === Single execution ===

    async def run_task(self, input_data: dict) -> dict:
        """Execute single Hoplet task

        Args:
            input_data: Hoplet input (per metainfo input contract)

        Returns:
            Hoplet output (per metainfo output contract) or {"error": str}
        """
        ...

    # === Batch testing ===

    async def list_test_files(self) -> list[dict]:
        """List available test files under TestCases/

        Returns:
            [{"name": str, "size": int, "records": int}, ...]
        """
        ...

    async def start_batch(self, filename: str, workers: int = 5) -> dict:
        """Start batch testing (non-blocking)

        Returns:
            {"status": "started", "total": int} or {"error": str}
        """
        ...

    async def get_batch_progress(self) -> dict:
        """Query batch testing progress

        Returns:
            {"running": bool, "completed": int, "total": int,
             "errors": int, "output_file": str}
        """
        ...

    # === Data queries ===

    async def list_results(self) -> list[dict]:
        """Scan TestCases/ file list

        Returns:
            [{"name": str, "size": int, "mtime": float}, ...]
        """
        ...

    async def load_result(self, filename: str) -> list[dict]:
        """Load single result file content

        Returns:
            Record list or {"error": str}
        """
        ...

    async def get_stats(self) -> dict:
        """Aggregate statistics (delegated to DataStore)

        Returns:
            {"total": int, "avg_score": float, ...}
        """
        self.datastore.load_results()
        return self.datastore.get_stats()

    async def get_perf_summary(self) -> dict:
        """Performance summary (delegated to DataStore querying observer logs)

        Returns:
            {"avg_duration": float, "p50": float, "p95": float, ...}
        """
        self.datastore.load_results()
        return self.datastore.get_perf_summary()
```

### Comparison with Existing `Api` Class

| Dimension | Existing `Api` (in `app.py`) | `HopletService` |
|-----------|-----------------------------|-----------------|
| Method Signature | Returns `str` (JSON string) | Returns `dict` (serialization handled by Transport) |
| Sync/Async | Sync (`asyncio.run()` bridge) | Pure async |
| Data Query | Manual `_parse_file` + Python loops | Delegated to `HopletDataStore` (DuckDB) |
| Observability | None | Records execution logs via `HopletObserver` |
| Transport Coupling | Directly bound to pywebview | Framework-independent, callable by any Transport |

---

## 6. Transport Layer — Unified HTTP

Under SSR architecture, pywebview and FastAPI share the same HTTP paths. pywebview accesses FastAPI endpoints via embedded uvicorn HTTP server, frontend uniformly uses HTMX to initiate requests and receive HTML fragment responses.

### pywebview Mode (app.py)

pywebview no longer uses JS API bridge (`window.pywebview.api.*`), but embeds uvicorn HTTP server, frontend accesses same endpoints as FastAPI via `http://localhost:{port}`.

```python
"""app.py — pywebview desktop mode (embedded uvicorn HTTP service)"""

import os, sys, threading
import uvicorn
import webview

VIEW_DIR = os.path.dirname(os.path.abspath(__file__))
HOPLOGIC_DIR = os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))
if VIEW_DIR not in sys.path:
    sys.path.insert(0, VIEW_DIR)
if HOPLOGIC_DIR not in sys.path:
    sys.path.insert(0, HOPLOGIC_DIR)

from config import VIEW_CONFIG
from hop_view import create_pywebview_app, BaseService

service = BaseService(VIEW_CONFIG, hoplet_dir=..., testcases_dir=...)
create_pywebview_app(VIEW_CONFIG, service, VIEW_DIR)
```

`create_pywebview_app()` internal flow:

1. Calls `create_fastapi_app()` to build FastAPI app (shares same endpoints + Jinja2 rendering as `web.py`)
2. Starts `uvicorn.Server` in background thread listening on `127.0.0.1:{free_port}`
3. Creates pywebview window, `url` points to `http://127.0.0.1:{port}`
4. Stops uvicorn server when window closes

```python
# Core implementation of create_pywebview_app (hop_view/transport.py)
def create_pywebview_app(config, service, view_dir, debug=None):
    app = create_fastapi_app(config, service, view_dir)
    uv_config = uvicorn.Config(app, host="127.0.0.1", port=0)
    server = uvicorn.Server(uv_config)
    thread = threading.Thread(target=server.run, daemon=True)
    thread.start()
    # ... wait for server ready, get actual port ...
    window = webview.create_window(
        config.task_name, url=f"http://127.0.0.1:{port}",
        width=1200, height=820, min_size=(900, 600),
    )
    webview.start(debug=_resolve_debug(debug))
    server.should_exit = True
```

**Features**:
- Local single-user use via localhost HTTP communication
- pywebview window manages lifecycle, uvicorn runs in background thread
- Shares identical endpoints and Jinja2 rendering logic with FastAPI mode

#### Debug Mode

`HOP_VIEW_DEBUG=1` or `--debug` enables Chrome DevTools:

```bash
HOP_VIEW_DEBUG=1 uv run --no-sync python Tasks/<TaskName>/View/app.py
```

### FastAPI Mode (web.py) — SSR Endpoints

FastAPI endpoints return `HTMLResponse` (Jinja2-rendered HTML fragments), HTMX directly inserts responses into DOM.

```python
"""web.py — FastAPI SSR Transport"""

import os, sys
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse

VIEW_DIR = os.path.dirname(os.path.abspath(__file__))
HOPLOGIC_DIR = os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))
if VIEW_DIR not in sys.path:
    sys.path.insert(0, VIEW_DIR)
if HOPLOGIC_DIR not in sys.path:
    sys.path.insert(0, HOPLOGIC_DIR)

from config import VIEW_CONFIG
from hop_view import create_fastapi_app, BaseService

service = BaseService(VIEW_CONFIG, hoplet_dir=..., testcases_dir=...)
app = create_fastapi_app(VIEW_CONFIG, service, VIEW_DIR)
```

`create_fastapi_app()` internal registered endpoints example:

```python
# SSR endpoints in hop_view/transport.py (registered by create_fastapi_app)

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    """Homepage — returns complete index.html"""
    return templates.TemplateResponse("index.html", {"request": request, "config": config})

@app.get("/tab/stats", response_class=HTMLResponse)
async def render_stats(request: Request):
    """Stats Tab — returns HTML fragment"""
    data = await service.get_stats()
    return render_stats_fragment(data, config)

@app.post("/tab/run", response_class=HTMLResponse)
async def render_run_result(request: Request):
    """Execution result — returns HTML fragment"""
    form = await request.form()
    result = await service.run_task(dict(form))
    return render_result_fragment(result, config)

@app.get("/tab/history", response_class=HTMLResponse)
async def render_history(request: Request):
    """History Tab — returns HTML fragment"""
    records = await service.list_results()
    return render_history_fragment(records, config)
```

**Features**:
- Endpoints return `HTMLResponse` (HTML fragments), HTMX inserts into DOM via `hx-swap`
- Jinja2 templates rendered server-side, frontend needs no JSON parsing or DOM building
- `Depends()` dependency injection: easy to extend authentication, rate limiting middleware
- `lifespan` manages shared resources (DuckDB connections, Observer file handles)

---

## 7. Frontend — HTMX Driven

### HTMX Interaction Model

Under SSR architecture, frontend no longer needs JS API adapters. Interactions are driven by HTMX declarative attributes directly initiating HTTP requests, server returns HTML fragments, HTMX automatically inserts responses into target DOM nodes.

Frontend JS code reduced from ~300 lines (JS API Adapter + JSON→DOM rendering) to ~100 lines (Tab switching, error overlay, form glue).

```html
<!-- Tab switching — HTMX declarative -->
<nav>
  <button hx-get="/tab/stats" hx-target="#tab-content" hx-swap="innerHTML"
          class="tab-btn active">Stats</button>
  <button hx-get="/tab/history" hx-target="#tab-content" hx-swap="innerHTML"
          class="tab-btn">History</button>
  <button hx-get="/tab/batch" hx-target="#tab-content" hx-swap="innerHTML"
          class="tab-btn">Batch</button>
  <button hx-get="/tab/perf" hx-target="#tab-content" hx-swap="innerHTML"
          class="tab-btn">Performance</button>
</nav>
<div id="tab-content">
  <!-- HTMX inserts server-returned HTML fragments here -->
</div>

<!-- Execution form — HTMX POST -->
<form hx-post="/tab/run" hx-target="#result-area" hx-swap="innerHTML"
      hx-indicator="#loading">
  <textarea name="context_window" placeholder="Context window"></textarea>
  <textarea name="model_output" placeholder="Model output"></textarea>
  <button type="submit">Execute</button>
  <span id="loading" class="htmx-indicator">Executing...</span>
</form>
<div id="result-area"></div>

<!-- Batch test progress polling — HTMX auto-trigger -->
<div hx-get="/tab/batch/progress" hx-trigger="every 2s [batch_running]"
     hx-target="#batch-progress" hx-swap="innerHTML">
</div>
```

### Frontend JS Responsibilities (~100 lines)

After SSR, frontend JS only handles three types of logic:

1. **Tab switching highlight**: Listen to `htmx:afterOnLoad` events, toggle `active` CSS class
2. **Error overlay**: Global error capture + appendError()
3. **Form glue**: Minimal logic control (e.g. batch test start/stop toggle)

```javascript
// Tab switching highlight (~15 lines)
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// Error overlay (~30 lines)
function appendError(msg, file, line) {
  const overlay = document.getElementById('error-overlay');
  const div = document.createElement('div');
  div.textContent = `${msg} (${file}:${line})`;
  overlay.appendChild(div);
  overlay.style.display = 'block';
}
window.addEventListener("error", (e) => appendError(e.message, e.filename, e.lineno));
window.addEventListener("unhandledrejection", (e) => appendError(String(e.reason)));

// HTMX error events (~10 lines)
document.addEventListener('htmx:responseError', (e) => {
  appendError('HTTP ' + e.detail.xhr.status + ': ' + e.detail.xhr.statusText);
});
```

### Frontend Constraints

#### Text Selectable (Global Default Policy)

pywebview disables page text selection by default. **Must use global `*` selector to make selectable, interactive controls opt-out**.

**Prohibited** to whitelist declare `user-select: text` per element (new elements will be missed).

```css
/* Correct: Global default selectable, interactive controls opt-out */
* { -webkit-user-select: text; user-select: text; }
button, input, select, .btn { -webkit-user-select: none; user-select: none; }
textarea { -webkit-user-select: text; user-select: text; }
```

```css
/* Incorrect: Whitelist per element, new elements will be missed */
body, textarea, .result-card, .json-block, .err-table td { user-select: text; }
```

**Test guarantee**: `test_web.py::TestIndexHtmlConstraints` includes two static checks:
1. `test_global_user_select_text` — must declare on `*` selector
2. `test_no_per_element_user_select_text` — prohibited per-element declaration (except `*` and `textarea`)

#### Error Overlay

In pywebview environment, JS errors are invisible (no console). index.html must embed error overlay, capture all unhandled exceptions and display at UI bottom:

```javascript
// Global error capture
window.addEventListener("error", (e) => appendError(e.message, e.filename, e.lineno));
window.addEventListener("unhandledrejection", (e) => appendError(e.reason));

// HTMX errors should also be captured
document.addEventListener("htmx:responseError", (e) => appendError("HTTP " + e.detail.xhr.status));
```

Error overlay displays at page bottom, red border, includes error message and stack info. Users can see errors without opening DevTools.

> **ChatFlow Component Detailed Design**: Interactive Hoplet's chat-flow layout (dialog flow, message cards, state machine, session management) see [Terms/ChatFlow Component Specification.md](ChatFlow组件规范.md).

### Five Tabs

| Tab | Name | Function | SSR Endpoint |
|-----|------|----------|--------------|
| 1 | Execute | Input data + execute Hoplet + result rendering | `POST /tab/run` |
| 2 | Batch | File selection + concurrency config + progress bar | `POST /tab/batch/start` / `GET /tab/batch/progress` |
| 3 | History | Left file list + right record details | `GET /tab/history` / `GET /tab/history/{name}` |
| 4 | Stats | Total cards + metric averages + distribution bar charts | `GET /tab/stats` |
| 5 | Performance | Average duration + percentiles + operator-level stats | `GET /tab/perf` |

First 4 tabs match existing Verify/View (execution audit, batch testing, historical results, stats overview). Tab 5 (performance monitoring) is new, displays execution performance data recorded by HopletObserver.

### Performance Monitoring Tab Content

```
┌──────────────────────────────────────────────┐
│  Performance Monitoring                      │
│                                              │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐       │
│  │  3.2s   │ │  2.8s   │ │  8.1s   │       │
│  │ Avg Time│ │  P50    │ │  P95    │       │
│  └─────────┘ └─────────┘ └─────────┘       │
│                                              │
│  Operator-level Statistics                   │
│  ┌─────────┬──────┬──────┬──────┬──────┐    │
│  │ Operator│ Calls│ Success│ Avg Time│ Retry│    │
│  ├─────────┼──────┼──────┼──────┼──────┤    │
│  │ hop_get │ 156  │ 95%  │ 2.1s │ 0.3  │    │
│  │ hop_judge│ 42  │ 90%  │ 3.4s │ 0.5  │    │
│  └─────────┴──────┴──────┴──────┴──────┘    │
└──────────────────────────────────────────────┘
```

---

## 8. Multi-user Service Extension

When providing Web Service via FastAPI (`web.py`), note these concurrency safety considerations.

### HopProc Global Singleton + Per-Request Independent Session

`HopProc` is stateless operator abstraction (holds LLM client and model config), can be global singleton shared. Each HTTP request creates independent `HopSession`:

```python
# Execution logic in web.py
async def run_task(req, service):
    hop_proc = service.hop_proc  # global singleton
    async with hop_proc.session() as s:
        # Each request independent session (independent dialog history, HopState, ExecutionStats)
        result = await hoplet_main(s, req.model_dump())
    return result
```

This follows HOP engine concurrency rules: **same session prohibits concurrent operator calls, create independent sessions for concurrency**.

### GLOBAL_STATS Thread Safety

`GLOBAL_STATS` (`ExecutionStats`) `merge_from()` method already uses `threading.Lock` protection, supports concurrent merging from multiple `HopSession.__aexit__`. No additional handling needed for Web Service scenarios.

### DuckDB Connection Management

ibis DuckDB backend's memory connections are not thread-safe. Two options:

1. **Single connection + read-write lock**: All queries serialized (suitable for read-heavy scenarios)
2. **Connection pool**: Each request gets independent connection (suitable for high concurrency)

Recommend option 1 (Hoplet View query concurrency typically low):

```python
class HopletDataStore:
    def __init__(self, testcases_dir: str):
        self.con = ibis.duckdb.connect()
        self._lock = threading.Lock()

    def get_stats(self) -> dict:
        with self._lock:
            t = self.con.table("results")
            total = t.count().execute()
            ...
```

### Authentication Example with Depends()

FastAPI's `Depends()` mechanism can flexibly extend authentication, rate limiting middleware:

```python
from fastapi import Depends, Header, HTTPException

async def verify_token(authorization: str = Header(...)):
    """Simple Bearer Token authentication"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid token")
    token = authorization[7:]
    # verify token...
    return token

@app.post("/api/run")
async def run_task(
    req: RunTaskRequest,
    service: HopletService = Depends(get_service),
    token: str = Depends(verify_token),  # add authentication
):
    return await service.run_task(req.model_dump())
```

---

## 9. ViewSpec — UI Specification Layer

### Overview

ViewSpec is the View layer's declarative specification directory (`View/ViewSpec/`), extracting UI customization logic from `/code2view` command templates into independent, auditable, diffable Markdown file sets.

ViewSpec serves dual roles—for each task's independently generated code Zone (**generated**), ViewSpec is **generation specification**; for shared library's already solidified code Zone (**shared**), ViewSpec is **interface contract** (records behavior + declares parameterized interfaces). Same ViewSpec directory can mix both roles. As code matures, Zones can progressively solidify from generated to shared.

Detailed format specification see `Terms/ViewSpec Format Specification.md` (§2.1 Zone implementation source).

### Directory Structure

```
View/ViewSpec/
├── index.md              # Overview: Tab list + Zone index + API adaptation + general behavior + primitives + file routing table
├── rendering.md          # Rendering mappings: input/output fields + composite components + result normalization + statistical aggregation
├── theme.md              # Layout theme: Design Tokens + layout dimensions + CSS class list + animations
└── tabs/                 # Interaction flows: one directory per Tab, one file per Zone
    ├── solve/            #   Execute Tab (example: chat-flow layout)
    │   ├── _tab.md       #     Tab overview: layout + Zone topology + event routing table
    │   ├── InputArea.md  #     Zone: input area
    │   ├── ChatFlow.md   #     Zone: message flow
    │   └── ChatInputBar.md #   Zone: feedback bar
    ├── batch/            #   Batch Tab
    │   ├── _tab.md
    │   └── BatchPanel.md
    └── ...
```

### Core Concept: Zone

Zone is ViewSpec's core structural unit, corresponding to an independent interactive partition on the interface. Each Zone has its own elements, state variables, event handlers. Zones communicate via message events (`emit` + routing table), direct manipulation of other Zones' internal state is prohibited.

### Layout Patterns

Each Tab declares layout pattern: `form + result` (form submission → result display), `chat-flow` (input + message flow + feedback bar), `sidebar + detail` (list + detail), etc. Layout patterns determine Zone composition.

### Relationship with metainfo

```
metainfo.md          ← data contract (input/output field types)
    ↓ derived
ViewSpec/            ← UI specification directory (rendering/interaction/theme)
    ↓ generated
View/ files          ← executable code
```

ViewSpec references metainfo's input/output contract fields, but adds rendering concerns (Widget type, thresholds, color rules, aggregation methods). metainfo says "reliability_score is int", ViewSpec says "render with gauge-circle, >=70 green, >=40 orange, <40 red".

### File Routing Table

When View uses `hop_view` shared library, runtime code is scattered across shared templates (`base.html`, `chatflow.css`, `run_result.html`), shared logic (`transport.py`), and task-level files (`config.py`, `app.py`). `index.md` should include **file routing table** — mapping of "what to change → which file to change" — to prevent mistakenly modifying snapshot file `index.html` or other non-target files. Format specification see `Terms/ViewSpec Format Specification.md` §1.7.

### Generation Pipeline

When `View/ViewSpec/index.md` exists, `/code2view` prioritizes reading ViewSpec directory as UI customization specification; when absent, falls back to direct inference from metainfo (backward compatible).

---

## 10. Integration with `/code2view` Command

### Generated Files (using hop_view shared library)

`/code2view` command generates 3 files (original observer.py, datastore.py, service.py replaced by shared library):

| File | Nature | Generation Strategy |
|------|--------|---------------------|
| `config.py` | ViewConfig declaration | **Semi-custom**: generates ViewConfig + FieldAggregation from metainfo input/output contracts |
| `app.py` | Transport (pywebview) | **Templated**: thin launcher, ~30 lines |
| `web.py` | Transport (FastAPI) | **Templated**: thin launcher, ~30 lines |
| `index.html` | Frontend | **Customized**: input fields, result rendering, stats metrics generated from metainfo input/output contracts |

> Note: Old `/code2view` generated 6 files (including observer.py, datastore.py, service.py). Using `hop_view` shared library, these common modules are replaced by `BaseDataStore`, `BaseService`, `HopletObserver`.

### Templated vs Customized

**Templated files** (`observer.py`): All Hoplet tasks share same code, `/code2view` directly copies template.

**Semi-custom files** (`service.py`, `datastore.py`): Structure fixed, but some methods need task-specific customization:
- `service.py`'s `run_task` method needs to import corresponding `Hop.py` and call its main function
- `datastore.py`'s `get_stats` method generates different aggregation logic per output contract field types

**Customized files** (`index.html`, `app.py`, `web.py`):
- `index.html`'s input forms, result rendering, stats cards generated from metainfo input/output contracts
- `app.py`'s `run_task` parameter list generated from input contract
- `web.py`'s Pydantic request models generated from input contract

### Statistical Logic Customization Rules

`datastore.py`'s `get_stats` method is driven by ViewConfig's `output_fields` configuration (`FieldAggregation`) to generate ibis expressions:

| agg_type | ibis expression | Example |
|----------|-----------------|---------|
| `mean` | `t[field].try_cast("float64").mean()` | `credit_score` → `avg_credit_score` |
| `rate` | `t[field].try_cast("bool").fill_null(False).sum() / total` | `hallucination_detected` → `hallucination_detected_rate` |
| `distribution` | DuckDB SQL: `UNNEST(from_json(field, ...)) GROUP BY sub_field` | `errors[].severity` → `errors_distribution` |
| `non_null_rate` | `t[field].notnull().sum() / total` | `summary` → `summary_non_null_rate` |

---

## 11. Dependencies and Launch

### Dependencies

All dependencies declared in `pyproject.toml`:

| Package | Purpose | `pyproject.toml` Declaration |
|---------|---------|------------------------------|
| `pywebview>=6.1` | Local desktop UI | existing |
| `ibis-framework[duckdb]>=10.0.0` | Query acceleration engine (ibis expression API + DuckDB backend) | existing |
| `pydantic>=2.12.5` | FastAPI request/response models | existing |

FastAPI and ASGI server need additional installation:

```bash
uv add fastapi uvicorn[standard]
```

### Launch Commands

All launchers support execution from any working directory (paths resolved via `__file__`, see "2. Path Resolution Constraints"):

```bash
# pywebview desktop mode (local single-user) — from any directory
uv run --no-sync python Tasks/<TaskName>/View/app.py

# pywebview debug mode (enable DevTools)
HOP_VIEW_DEBUG=1 uv run --no-sync python Tasks/<TaskName>/View/app.py

# FastAPI Web Service (multi-user online) — from any directory
uv run --no-sync uvicorn web:app --host 0.0.0.0 --port 8000 --app-dir Tasks/<TaskName>/View

# FastAPI development mode (auto-reload)
uv run --no-sync uvicorn web:app --reload --port 8000 --app-dir Tasks/<TaskName>/View
```

After FastAPI starts, visit `http://localhost:8000` for UI, `http://localhost:8000/docs` for auto-generated API docs.

---

## 12. hop_view Shared Library

### Overview

`hoplogic/hop_view/` is View layer's shared library, extracting ~80% common logic from each task's View code. Each task only needs to declare `ViewConfig` + thin launcher to reuse all functionality.

Detailed API reference: `hoplogic/docs/hop_view.md`
Configuration specification: `Terms/HopView Shared Library Specification.md`

### Shared Library Package Structure

```
hoplogic/hop_view/
├── __init__.py            # Package init, __version__="0.3.0", __all__ exports
├── config_schema.py       # ViewConfig + FieldAggregation dataclass definitions
├── observer.py            # HopletObserver + _RunTracer (structured execution logs)
├── file_utils.py          # parse_file() common file parsing
├── hop_loader.py          # ensure_hop() dynamic loading + resolve_task_paths()
├── datastore.py           # BaseDataStore — configuration-driven DuckDB queries
├── service.py             # BaseService — configuration-driven business logic
├── transport.py           # create_fastapi_app() / create_pywebview_app() factories
├── renderer.py            # Jinja2 renderer — HTML fragment generation (render_*_fragment)
├── templates/             # Jinja2 template directory (Tab fragments, result cards, stats panels, etc.)
├── batch_runner.py        # CLI batch test runner
└── test/                  # Test suite (172 test cases)
```

### Post-Migration Task Directory Structure

Using shared library, each task's `View/` directory is greatly simplified:

```
Tasks/<TaskName>/View/
├── ViewSpec/          # unchanged
├── config.py          # ~35 lines — ViewConfig declaration
├── app.py             # ~30 lines — thin launcher
├── web.py             # ~30 lines — thin launcher
└── index.html         # unchanged
```

Old 6 Python files (observer.py, datastore.py, service.py, app.py, web.py + test/) totaled ~3991 lines, post-migration only ~100 lines task-specific code + index.html needed.

### Usage

**config.py**:
```python
from hop_view.config_schema import ViewConfig, FieldAggregation
VIEW_CONFIG = ViewConfig(task_name="Verify", hop_func_name="verify_hop", ...)
```

**app.py** (thin launcher, supports any directory launch):
```python
import os, sys
VIEW_DIR = os.path.dirname(os.path.abspath(__file__))
HOPLOGIC_DIR = os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))
if VIEW_DIR not in sys.path:
    sys.path.insert(0, VIEW_DIR)
if HOPLOGIC_DIR not in sys.path:
    sys.path.insert(0, HOPLOGIC_DIR)
from config import VIEW_CONFIG
from hop_view import create_pywebview_app, BaseService, HopletObserver
service = BaseService(VIEW_CONFIG, hoplet_dir, testcases_dir, observer=...)
create_pywebview_app(VIEW_CONFIG, service, VIEW_DIR)
```

**web.py** (thin launcher, supports any directory launch):
```python
import os, sys
VIEW_DIR = os.path.dirname(os.path.abspath(__file__))
HOPLOGIC_DIR = os.path.abspath(os.path.join(VIEW_DIR, "..", "..", "..", "hoplogic"))
if VIEW_DIR not in sys.path:
    sys.path.insert(0, VIEW_DIR)
if HOPLOGIC_DIR not in sys.path:
    sys.path.insert(0, HOPLOGIC_DIR)
from config import VIEW_CONFIG
from hop_view import create_fastapi_app, BaseService, HopletObserver
service = BaseService(VIEW_CONFIG, hoplet_dir, testcases_dir, observer=...)
app = create_fastapi_app(VIEW_CONFIG, service, VIEW_DIR)
```

### Relationship with Per-Task Code

| Module | Old (per-task generated) | New (shared library) |
|--------|-------------------------|---------------------|
| observer.py | per-task (110 lines) | `hop_view.observer` (shared) |
| datastore.py | per-task (468 lines) | `hop_view.datastore.BaseDataStore` (config-driven) |
| service.py | per-task (289 lines) | `hop_view.service.BaseService` (config-driven) |
| web.py | per-task (161 lines) | `hop_view.transport.create_fastapi_app()` (factory) |
| app.py | per-task (117 lines) | `hop_view.transport.create_pywebview_app()` (factory) |
| test/ | per-task (~2000 lines) | `hop_view/test/` (172 test cases, shared) |

---

## 13. Testing

### Test Scope

`/code2view` generated test suite covers 4 Python backend modules, doesn't test `app.py` (pywebview needs GUI) or `index.html` (frontend JS).

| Test File | Module Under Test | Nature | ~Test Count |
|-----------|-------------------|--------|-------------|
| `test_observer.py` | `observer.py` | templated | ~15 |
| `test_datastore.py` | `datastore.py` | semi-custom | ~20 |
| `test_service.py` | `service.py` | semi-custom | ~20 |
| `test_web.py` | `web.py` | customized | ~15 |

### pytest asyncio_mode = auto Constraint

Project uses `asyncio_mode = auto` (`hoplogic/pytest.ini`), async test functions auto-detected, no `@pytest.mark.asyncio` needed. async fixtures recommend `@pytest_asyncio.fixture` decorator (not `@pytest.fixture`).

```python
import pytest_asyncio

@pytest_asyncio.fixture
async def client(app):
    """Async HTTP client — must use @pytest_asyncio.fixture"""
    async with LifespanManager(app) as manager:
        transport = ASGITransport(app=manager.app)
        async with AsyncClient(transport=transport, base_url="http://test") as c:
            yield c
```

### Test Layers

```
Pure logic     test_observer.py     HopletObserver, _RunTracer (file I/O + thread safety)
Pure logic     test_datastore.py    HopletDataStore (DuckDB queries + aggregation)
Mock I/O       test_service.py      HopletService (mock _ensure_hop + Hop module)
Mock HTTP      test_web.py          FastAPI endpoints (httpx.AsyncClient + ASGITransport)
```

### Shared Fixtures (conftest.py)

| Fixture | Purpose |
|---------|---------|
| `sample_audit_records()` | Returns dict list conforming to output contract |
| `tmp_testcases(tmp_path)` | Creates temporary TestCases directory + sample JSONL |
| `tmp_observer_log(tmp_path)` | Creates temporary observer.jsonl (run_start/step/run_end) |

Fixtures' sample data customized per task output contract.

### Mock Strategy

| Mocked Object | Mock Method | Purpose |
|---------------|-------------|---------|
| `_hop_module` / `_hop_load_error` | Direct module variable setting | Avoid real Hop.py import |
| `hop.verify_hop` | `AsyncMock(return_value=...)` | Mock Hop main function |
| `hop.hop_proc.session()` | `AsyncMock` context manager | Mock HopSession |
| `hop.GLOBAL_STATS` | `MagicMock()` | Mock global stats |
| `app.state.service` | Inject `MagicMock` | Web endpoint tests don't depend on real Service |

Each test resets `_hop_module` and `_hop_load_error` via `autouse` fixture before test.

### Run Commands

```bash
# Run all tests
cd Tasks/<TaskName>/View && uv run --no-sync pytest test/ -v

# Run single test file
cd Tasks/<TaskName>/View && uv run --no-sync pytest test/test_observer.py -v

# Coverage report
cd Tasks/<TaskName>/View && uv run --no-sync pytest test/ -v --cov=. --cov-report=term-missing
```

### Coverage Requirements

4 modules under test (observer.py, datastore.py, service.py, web.py) each **>= 99%**. `app.py` and `index.html` excluded from coverage stats.